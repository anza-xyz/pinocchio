//! Errors generated by programs.
//!
//! Current implementation is based on the `ProgramError` enum from
//! the Solana SDK:
//!
//! <https://github.com/anza-xyz/solana-sdk/blob/master/program-error/src/lib.rs>
//!
//! Considerations:
//!
//! - Not deriving `thiserror::Error` for now, as it's not clear if it's needed.

/// Reasons the program may fail.
#[derive(Clone, Debug, Eq, PartialEq)]
#[repr(u8)]
pub enum ProgramError {
    /// Allows on-chain programs to implement program-specific error types and see them returned
    /// by the Solana runtime. A program-specific error may be any type that is represented as
    /// or serialized to a u32 integer.
    ///
    /// Custom program error: `{0:#x}`
    Custom(u32) = 1,

    /// The arguments provided to a program instruction were invalid
    InvalidArgument = 2,

    /// An instruction's data contents was invalid
    InvalidInstructionData = 3,

    /// An account's data contents was invalid
    InvalidAccountData = 4,

    /// An account's data was too small
    AccountDataTooSmall = 5,

    /// An account's balance was too small to complete the instruction
    InsufficientFunds = 6,

    /// The account did not have the expected program id
    IncorrectProgramId = 7,

    /// A signature was required but not found
    MissingRequiredSignature = 8,

    /// An initialize instruction was sent to an account that has already been initialized
    AccountAlreadyInitialized = 9,

    /// An attempt to operate on an account that hasn't been initialized
    UninitializedAccount = 10,

    /// The instruction expected additional account keys
    NotEnoughAccountKeys = 11,

    /// Failed to borrow a reference to account data, already borrowed
    AccountBorrowFailed = 12,

    /// Length of the seed is too long for address generation
    MaxSeedLengthExceeded = 13,

    /// Provided seeds do not result in a valid address
    InvalidSeeds = 14,

    /// IO Error
    BorshIoError = 15,

    /// An account does not have enough lamports to be rent-exempt
    AccountNotRentExempt = 16,

    /// Unsupported sysvar
    UnsupportedSysvar = 17,

    /// Provided owner is not allowed
    IllegalOwner = 18,

    /// Accounts data allocations exceeded the maximum allowed per transaction
    MaxAccountsDataAllocationsExceeded = 19,

    /// Account data reallocation was invalid
    InvalidRealloc = 20,

    /// Instruction trace length exceeded the maximum allowed per transaction
    MaxInstructionTraceLengthExceeded = 21,

    /// Builtin programs must consume compute units
    BuiltinProgramsMustConsumeComputeUnits = 22,

    /// Invalid account owner
    InvalidAccountOwner = 23,

    /// Program arithmetic overflowed
    ArithmeticOverflow = 24,

    /// Account is immutable
    Immutable = 25,

    /// Incorrect authority provided
    IncorrectAuthority = 26,
}

/// Builtin return values occupy the upper 32 bits
const BUILTIN_BIT_SHIFT: usize = 32;

impl From<ProgramError> for u64 {
    fn from(error: ProgramError) -> Self {
        match error {
            ProgramError::Custom(error) => {
                if error == 0 {
                    // CUSTOM_ZERO
                    1 << BUILTIN_BIT_SHIFT
                } else {
                    error as u64
                }
            }
            // SAFETY: the discriminant is always the first field for non Custom
            _ => {
                let discriminant = unsafe { *(&error as *const ProgramError as *const u8) };
                (discriminant as u64) << BUILTIN_BIT_SHIFT
            }
        }
    }
}

impl From<u64> for ProgramError {
    fn from(value: u64) -> Self {
        let discriminant = (value >> BUILTIN_BIT_SHIFT) as u32;
        match discriminant {
            1 => Self::Custom(0),
            // SAFETY: the discriminant is always the first field for non Custom
            2..=26 => unsafe { (*(&discriminant as *const u32 as *const ProgramError)).clone() },
            _ => Self::Custom(value as u32),
        }
    }
}
